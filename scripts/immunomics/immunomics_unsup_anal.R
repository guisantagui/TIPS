################################################################################
# TIPS: Do PCAs of the immunomics RDS objects generated by parse_immunomics.   #
################################################################################

if (!require("plotUtils", quietly = T)){
        devtools::install_github("guisantagui/plotUtils", upgrade = "never")
}
library(plotUtils)

if (!require("isotree", quietly = T)){
        install.packages("isotree")
}
library(isotree)
if(!require("gplots", quietly = T)) install.packages("gplots")
library(gplots)
if(!require("ComplexHeatmap", quietly = T)) install.packages("ComplexHeatmap")
library(ComplexHeatmap)
if (!require("M3C", quietly = T)){
        BiocManager::install("M3C", update = F)
}
library(M3C)

# Directory stuff
################################################################################
parsed_dir <- "/Users/guillem.santamaria/Documents/postdoc/comput/TIPS/results/immunomics/parsed/"
subset <- "counts"
OL_quant_thrshld <- 0.90
outDir <- "/Users/guillem.santamaria/Documents/postdoc/comput/TIPS/results/immunomics/unsup_analysis/"

outDir <- sprintf("%s%s/", outDir, subset)
create_dir_if_not(outDir)

# Functions
################################################################################

# Creates a list of multi-scoreplots from a list of PCAs
plot_pca_list <- function(pca_lst,
                          samp_info_list,
                          labs_list = rep(list(NULL),
                                          length(pca_lst)),
                          col = NULL,
                          nComps = 5,
                          biplot = T,
                          topNFeats = 5,
                          point_size = 3,
                          multplot = T){
        if (multplot){
                fun <- function(pca, si, labs){
                        plt <- plotUtils::doPCAMultiPlot(pca,
                                                         samp_info = si,
                                                         col = col,
                                                         nComps = nComps,
                                                         biplot = biplot,
                                                         topNFeats = topNFeats,
                                                         point_size = point_size,
                                                         labs = labs)
                        return(plt)
                }
        }else{
                fun <- function(pca, si, labs){
                        plt <- plotUtils::plotPCA(pca,
                                                  samp_info = si,
                                                  col = col,
                                                  biplot = biplot,
                                                  topNFeats = topNFeats,
                                                  point_size = point_size,
                                                  fix_coord = F,
                                                  labs = labs)
                        return(plt)
                }
        }
        plot_list <- mapply(fun,
                            pca_lst,
                            samp_info_list,
                            labs_list,
                            SIMPLIFY = F)
        return(plot_list)
}

# Given a list of plots, saves them.
save_plotList <- function(plot_list, outDir, tag, height, width){
        mapply(function(p, n) save_plot(filename = sprintf("%s%s_%s.pdf",
                                                           outDir,
                                                           n,
                                                           tag),
                                        plot = p,
                                        height = height,
                                        width = width),
               plot_list,
               names(plot_list),
               SIMPLIFY = F)
}

# pca_red_var. If set to a value between 0 and 1, the dimensionality of the
# input data will be reduced with PCA to keep the indicated amount of variance
# before fitting the isolation forest.
detectOLs_isfrst <- function(dat,
                             quant_thrs = 0.95,
                             group_wise = F,
                             samp_info = NULL,
                             groups_in = NULL,
                             pca_red_var = NULL,
                             prob_pick_pooled_gain = 1){
        if (!is.null(pca_red_var)){
                if (class(pca_red_var) != "numeric" | length(pca_red_var) != 1){
                        stop("pca_red_var has to be a numeric value.")
                }
                if (!(pca_red_var <= 1 & pca_red_var >= 0)){
                        stop("pca_red_var has to be between 0 and 1.")
                }
                dat_pca <- prcomp(dat, scale. = F, center = F)
                pca_imp <- summary(dat_pca)$importance
                max_pc_idx <- which(pca_imp["Cumulative Proportion", ] >= pca_red_var)[1]
                dat <- dat_pca$x[, 1:max_pc_idx]
        }
        if (group_wise){
                if (is.null(samp_info) | is.null(groups_in)){
                        stop("If group_wise == T, samp_info DF and variable where the groupings are (groups_in) needs to be provided.",
                             call. = F)
                }
                if (!"sample" %in% colnames(samp_info)){
                        stop("samp_info doesn't have a 'sample' column",
                             call. = F)
                }
                if (!groups_in %in% colnames(samp_info)){
                        stop(sprintf("%s isn't a column of samp_info",
                                     groups_in),
                             call. = F)
                }
                groups <- unique(samp_info[, groups_in])
                ols <- c()
                as_df <- data.frame(matrix(ncol = 2, nrow = 0,
                                           dimnames = list(NULL, c("sample",
                                                                   "anomaly_score"))))
                for (g in groups){
                        i_f <- isolation.forest(dat[samp_info$sample[samp_info[, groups_in] == g], ],
                                                ndim = 1,
                                                sample_size = 36,
                                                ntrees = 100,
                                                prob_pick_pooled_gain = prob_pick_pooled_gain)
                        if_pred <- predict(i_f, dat[samp_info$sample[samp_info[, groups_in] == g], ])
                        to_bind <- data.frame(sample = names(if_pred),
                                              anomaly_score = if_pred)
                        thrshld <- quantile(if_pred, probs = quant_thrs)
                        ols_group <- names(if_pred)[if_pred >= thrshld]
                        ols <- c(ols, ols_group)
                        as_df = rbind.data.frame(as_df, to_bind)
                }
        }else{
                i_f <- isolation.forest(dat,
                                        ndim = 1,
                                        sample_size = 36,
                                        ntrees = 100,
                                        prob_pick_pooled_gain = 1)
                if_pred <- predict(i_f, dat)
                thrshld <- quantile(if_pred, probs = quant_thrs)
                ols <- names(if_pred)[if_pred >= thrshld]
                as_df <- data.frame(sample = names(if_pred),
                                    anomaly_score = if_pred)
        }
        as_df <- as_df[order(as_df$anomaly_score, decreasing = T), ]
        out <- list(outliers = ols,
                    anomaly_scores = as_df)
        return(out)
}

# Apply isolation forest outlier detection over list object
detectOLs_isfrst_list <- function(obj,
                                  slot,
                                  quant_thrs = 0.95,
                                  group_wise = F,
                                  groups_in,
                                  pca_red_var,
                                  prob_pick_pooled_gain = 1){
        for (i in seq_along(obj)){
                ols <- detectOLs_isfrst(obj[[i]][[slot]],
                                        quant_thrs = quant_thrs,
                                        group_wise = group_wise,
                                        samp_info = obj[[i]]$sample_info,
                                        groups_in = groups_in,
                                        pca_red_var = pca_red_var,
                                        prob_pick_pooled_gain = prob_pick_pooled_gain)
                obj[[i]][[sprintf("%s_OLs", slot)]] <- ols
        }
        return(obj)
}

filt_samps <- function(obj, keep_var = NULL,
                       keep_val = NULL,
                       keep_samps = NULL){
        if (is.null(keep_var) & is.null(keep_val)){
                if (is.null(keep_samps)){
                        stop("If keep_var and keep_val are NULL a vector keep_samp with samples to keep needs to be given.",
                             call. = F)
                }
        }else if (xor(is.null(keep_var), is.null(keep_val))){
                stop("Both keep_var and keep_val need to be provided for them to be used",
                     call. = F)
        }else if (!is.null(keep_var) & !is.null(keep_val)){
                if (!is.null(keep_samps)){
                        warning("As keep_var and keep_val are provided, keep_samps won't be used.",
                                call. = F)
                }
                keep_samps <- obj$sample_info$sample[obj$sample_info[, keep_var] %in% keep_val]
        }
        obj$sample_info <- obj$sample_info[obj$sample_info$sample %in% keep_samps, ]
        slots <- names(obj)
        slots <- slots[slots != "sample_info"]
        slots <- slots[!grepl("OLs", slots)]
        for (s in slots){
                obj[[s]] <- obj[[s]][rownames(obj[[s]]) %in% obj$sample_info$sample, ]
        }
        return(obj)
}

do_stand <- function(obj, slot = "data"){
        obj$stand <- stand(obj[[slot]])
        return(obj)
}

doHeatmap <- function(obj_4_hm, slot, col, filt_vars = "none", aov_alpha = 0.05,
                      pca_var_thrshld = .9, top_n_contrib = 20, subset = "counts",
                      rownames = T, rownames_size = 1,
                      colnames = T, colnames_size = 5){
        #obj_4_hm <- obj$l1
        #obj_4_hm <- objs$imm_counts_parsed_none$l5
        #obj_4_hm <- objs$imm_counts_parsed_drr$l5
        
        #slot <- "stand"
        #col <- "group"
        #filt_vars <- "ANOVA"
        #aov_alpha <- 0.05
        df <- obj_4_hm[[slot]]
        samp_info <- obj_4_hm$sample_info
        group_labs <- samp_info[match(rownames(df),
                                      samp_info$sample),
                                col]
        colorOrd <- as.numeric(factor(group_labs))
        unique_groups <- levels(factor(group_labs))
        group_cols <- setNames(rainbow(length(unique_groups)),
                               unique_groups)
        
        if (filt_vars == "ANOVA"){
                aov_pvals <- p.adjust(apply(df,
                                            2,
                                            function(x) summary(aov(x ~ group_labs))[[1]][["Pr(>F)"]][1]),
                                      method = "BH")
                keep_vars <- names(aov_pvals)[aov_pvals <= aov_alpha]
                df <- df[, colnames(df) %in% keep_vars]
        }else if(filt_vars == "PCA"){
                pca_result <- prcomp(df, center = F, scale. = F)
                summary(pca_result)
                explained_variance <- cumsum(pca_result$sdev^2 / sum(pca_result$sdev^2))
                num_pcs <- min(which(explained_variance >= pca_var_thrshld))
                contrib <- factoextra::facto_summarize(pca_result, "var", axes = 1:num_pcs)
                contrib <- contrib[order(contrib$contrib, decreasing = T),
                                   c("name", "contrib")]
                
                keep_vars <- as.character(contrib$name[1:top_n_contrib])
                df <- df[, colnames(df) %in% keep_vars]
        }
        df <- as.matrix(df)
        col_fun <- circlize::colorRamp2(c(min(df),
                                          mean(df),
                                          max(df)), c("blue",
                                                      "white",
                                                      "red"))
        samp_annot <- HeatmapAnnotation(group = group_labs,
                                        col = list(group = group_cols))
        plt <- Heatmap(t(df),
                       name = subset,
                       col = col_fun,
                       cluster_rows = TRUE,
                       cluster_columns = TRUE,
                       clustering_distance_rows = "euclidean",
                       clustering_method_rows = "ward.D",
                       clustering_distance_columns = "euclidean",
                       clustering_method_columns = "ward.D",
                       show_column_names = colnames,
                       show_row_names = rownames,
                       column_names_gp = gpar(fontsize = colnames_size),
                       row_names_gp = gpar(fontsize = rownames_size),
                       top_annotation = samp_annot)
        return(plt)
}

plot_hca_list <- function(obj, slot, col, filt_vars = "none", aov_alpha = 0.05,
                          pca_var_thrshld = .9, top_n_contrib = 20,
                          subset = "counts", rownames = T,
                          rownames_size = 1,
                          colnames = T, colnames_size = 5){
        obj 
        plt_lst <- list()
        for(i in seq_along(obj)){
                obj_name <- names(obj)[i]
                obj_4_hm <- obj[[i]]
                plt <- doHeatmap(obj_4_hm,
                                 slot,
                                 col,
                                 filt_vars,
                                 aov_alpha,
                                 pca_var_thrshld,
                                 top_n_contrib,
                                 subset,
                                 rownames,
                                 rownames_size,
                                 colnames,
                                 colnames_size)
                plt_lst[[obj_name]] <- plt
        }
        return(plt_lst)
}

save_hca_plotlist <- function(plt_lst, outDir, tag, height, width){
        for(i in seq_along(plt_lst)){
                lvl <- names(plt_lst)[i]
                pdf(sprintf("%s%s_%s.pdf",
                            outDir,
                            lvl,
                            tag),
                    height = height,
                    width = width)
                draw(plt_lst[[i]])
                dev.off()
        }
}

do_log2 <- function(obj, slot = "data", add_base = 0){
        obj$log2 <- log2(obj[[slot]] + add_base)
        return(obj)
}

do_stand <- function(obj, slot = "data"){
        obj$stand <- stand(obj[[slot]])
        return(obj)
}

filt_samps <- function(obj, keep_var = NULL,
                       keep_val = NULL,
                       keep_samps = NULL){
        if (is.null(keep_var) & is.null(keep_val)){
                if (is.null(keep_samps)){
                        stop("If keep_var and keep_val are NULL a vector keep_samp with samples to keep needs to be given.",
                             call. = F)
                }
        }else if (xor(is.null(keep_var), is.null(keep_val))){
                stop("Both keep_var and keep_val need to be provided for them to be used",
                     call. = F)
        }else if (!is.null(keep_var) & !is.null(keep_val)){
                if (!is.null(keep_samps)){
                        warning("As keep_var and keep_val are provided, keep_samps won't be used.",
                                call. = F)
                }
                keep_samps <- obj$sample_info$sample[obj$sample_info[, keep_var] %in% keep_val]
        }
        obj$sample_info <- obj$sample_info[obj$sample_info$sample %in% keep_samps, ]
        slots <- names(obj)
        slots <- slots[slots != "sample_info"]
        slots <- slots[!grepl("OLs", slots)]
        for (s in slots){
                obj[[s]] <- obj[[s]][rownames(obj[[s]]) %in% obj$sample_info$sample, ]
        }
        return(obj)
}

# Performs consensus clustering on a dataframe and returns
# object consisting in consensus clustering results and assignments dataframe.
cons_clust <- function(df, clusteralg = "pam", maxK = 5){
        res <- M3C(df,
                   removeplots = TRUE,
                   iters=25,
                   objective='PAC',
                   fsize=8,
                   lthick=1,
                   dotsize=1.25,
                   clusteralg = clusteralg,
                   maxK = maxK)
        
        assigns_df <- data.frame(sample = gsub("samp.",
                                               "",
                                               colnames(df)),
                                 group = factor(res$assignments))
        out <- list(m3c_result = res,
                    assignments_df = assigns_df)
        return(out)
}

# Applies cons_clust over a list, both to all samples, and only to sepsis
# samples.
cons_clust_list <- function(obj, slot = "stand", clusteralg = "pam"){
        
        #slot <- "stand"
        #clusteralg <- "pam"
        # Filter object to keep only sepsis samples
        obj_sepsis <- lapply(obj,
                             function(x) filt_samps(x,
                                                    keep_samps = x$sample_info$sample[x$sample_info$group == "sepsis"]))
        obj_sepsis <- lapply(obj_sepsis,
                             do_stand,
                             slot = "log2")
        for(i in seq_along(obj)){
                #i <- 4
                lvl <- names(obj)[i]
                obj_lvl <- obj[[lvl]]
                obj_lvl_dat <- obj_lvl[[slot]]
                obj_lvl_dat <- t(obj_lvl_dat)
                colnames(obj_lvl_dat) <- paste0("samp.",
                                                colnames(obj_lvl_dat))
                print(sprintf("%s, all samples", lvl))
                res_lvl <- cons_clust(obj_lvl_dat,
                                      clusteralg = clusteralg,
                                      maxK = 10)
                assigns_df <- res_lvl$assignments_df
                samp_info <- obj_lvl$sample_info
                samp_info$cons_clust_grouping <- assigns_df$group[match(samp_info$sample,
                                                                        assigns_df$sample)]
                # Do PCAs to see how the defined clusters look like
                obj_lvl_dat_4pca <- t(obj_lvl_dat)
                rownames(obj_lvl_dat_4pca) <- gsub(".*\\.", "",
                                                   rownames(obj_lvl_dat_4pca))
                dat_pca <- prcomp(obj_lvl_dat_4pca, scale. = F, center = F)
                pca_plt_cons_clust <- plotUtils::plotPCA(dat_pca,
                                                         samp_info = samp_info,
                                                         col = "cons_clust_grouping",
                                                         fix_coord = F) +
                        ggplot2::ggtitle("Groups defined by cons. clust.")
                pca_plt_group <- plotUtils::plotPCA(dat_pca,
                                                    samp_info = samp_info,
                                                    col = "group",
                                                    fix_coord = F) +
                        ggplot2::ggtitle("Groups (3 categories).")
                pca_plt_clin_regroup <- plotUtils::plotPCA(dat_pca,
                                                           samp_info = samp_info,
                                                           col = "clin_regrouping",
                                                           fix_coord = F) +
                        ggplot2::ggtitle("Clinical regrouping")
                #pca_plts <- ggpubr::ggarrange(pca_plt_cons_clust,
                #                              pca_plt_group,
                #                              pca_plt_clin_regroup)
                
                # Now do consensus clustering only of sepsis
                obj_sepsis_lvl_dat <- obj_sepsis[[lvl]][[slot]]
                print(obj_sepsis_lvl_dat[1:5, 1:5])
                obj_sepsis_lvl_dat <- t(obj_sepsis_lvl_dat)
                colnames(obj_sepsis_lvl_dat) <- paste0("samp.",
                                                       colnames(obj_sepsis_lvl_dat))
                print(sprintf("%s, sepsis samples", lvl))
                res_lvl_sepsis <- cons_clust(obj_sepsis_lvl_dat,
                                             clusteralg = clusteralg,
                                             maxK = 10)
                assigns_sepsis_df <- res_lvl_sepsis$assignments_df
                samp_info$group_sepsis_consclust_subgroup <- samp_info$group
                
                samp_info$group_sepsis_consclust_subgroup[samp_info$group_sepsis_consclust_subgroup == "sepsis"] <- paste0("sepsis_",
                                                                                                                           assigns_sepsis_df$group[match(samp_info$sample[samp_info$group_sepsis_consclust_subgroup == "sepsis"],
                                                                                                                                                         assigns_sepsis_df$sample)])
                pca_plt_group_sepsis_consclust_subgroup <- plotUtils::plotPCA(dat_pca,
                                                                              samp_info = samp_info,
                                                                              col = "group_sepsis_consclust_subgroup",
                                                                              fix_coord = F) +
                        ggplot2::ggtitle("Groups w/ sepsis divided by cons. clust.")
                
                pca_plts <- ggpubr::ggarrange(pca_plt_cons_clust,
                                              pca_plt_group_sepsis_consclust_subgroup,
                                              pca_plt_group,
                                              pca_plt_clin_regroup)
                
                obj_lvl$sample_info <- samp_info
                obj_lvl$cons_clust_res <- res_lvl$m3c_result
                obj_lvl$cons_clust_pcas <- pca_plts
                obj[[lvl]] <- obj_lvl
        }
        return(obj)
}

# Load data
################################################################################
obj_files <- list.files(parsed_dir, full.names = T)[grep(subset,
                                                         list.files(parsed_dir))]

objs <- list()
for (of in obj_files){
        o_name <- gsub("\\..*", "", basename(of))
        objs[[o_name]] <- readRDS(of)
}

# Do HCAs
################################################################################
hca_dir <- sprintf("%shca/", outDir)
create_dir_if_not(hca_dir)

for (i in seq_along(objs)){
        obj <- objs[[i]]
        obj_name <- names(objs)[i]
        # Get the treatment and create subdirectory
        if(!grepl("LPS|none|R848|drr|LPSminusNone|R848minusNone", obj_name)){
                treat <- "all"
        }else{
                treat <- strsplit(obj_name, split = "_")[[1]][4]
        }
        hca_dir_treat <- sprintf("%s%s/", hca_dir, treat)
        create_dir_if_not(hca_dir_treat)
        hca_obj_by_group <- plot_hca_list(obj,
                                          slot = "stand",
                                          col = "group",
                                          filt_vars = "none",
                                          aov_alpha = .05,
                                          rownames = F)
        hca_obj_by_clin_subgrp <- plot_hca_list(obj,
                                                slot = "stand",
                                                col = "clin_regrouping",
                                                filt_vars = "none",
                                                aov_alpha = .05,
                                                rownames = F)
        
        save_hca_plotlist(hca_obj_by_group,
                          outDir = hca_dir_treat,
                          tag = "group_hca",
                          height = 10,
                          width = 10)
        save_hca_plotlist(hca_obj_by_clin_subgrp,
                          outDir = hca_dir_treat,
                          tag = "clin_regrouping_hca",
                          height = 10,
                          width = 10)
}

# Do Consensus Clustering
################################################################################
cons_clust_dir <- sprintf("%scons_clust/", outDir)
create_dir_if_not(cons_clust_dir)

for (i in seq_along(objs)){
        obj_name <- names(objs)[i]
        obj <- objs[[i]]
        obj <- cons_clust_list(obj, "stand", "pam")
        # Get the treatment and create subdirectory
        if(!grepl("LPS|none|R848|drr|LPSminusNone|R848minusNone", obj_name)){
                treat <- "all"
        }else{
                treat <- strsplit(obj_name, split = "_")[[1]][4]
        }
        consclust_dir_treat <- sprintf("%s%s/", cons_clust_dir, treat)
        create_dir_if_not(consclust_dir_treat)
        for (j in seq_along(obj)){
                lvl <- names(obj)[j]
                lvl_plt <- obj[[lvl]]$cons_clust_pcas
                save_plot(filename = sprintf("%s%s_consClustPCA.pdf",
                                             consclust_dir_treat,
                                             lvl),
                          plot = lvl_plt,
                          height = 10, width = 12)
        }
        obj$l4$cons_clust_res
        objs[[obj_name]] <- obj
}

saveRDS(objs, file = sprintf("%scounts_object_with_cons_clust_cats.rds",
                             cons_clust_dir))

# Do PCAs
################################################################################
pca_dir <- sprintf("%spca/", outDir)
create_dir_if_not(pca_dir)

for (i in seq_along(objs)){
        obj <- objs[[i]]
        obj_name <- names(objs)[i]
        # Detect outliers (for labeling in PCA) and assign object to list
        obj <- detectOLs_isfrst_list(obj,
                                     slot = "stand",
                                     quant_thrs = OL_quant_thrshld,
                                     group_wise = T,
                                     groups_in = "group",
                                     pca_red_var = 0.95,
                                     prob_pick_pooled_gain = 1)
        #objs[[i]] <- obj
        
        # Get the treatment and create subdirectory
        if(!grepl("LPS|none|R848|drr|LPSminusNone|R848minusNone", obj_name)){
                print("jaja")
                treat <- "all"
        }else{
                treat <- strsplit(obj_name, split = "_")[[1]][4]
        }
        pca_dir_treat <- sprintf("%s%s/", pca_dir, treat)
        create_dir_if_not(pca_dir_treat)
        
        if (treat == "drr"){
                # Remove outliers --> Ratio calculation amplifies outliers
                obj <- lapply(obj,
                              function(x) filt_samps(x,
                                                     keep_samps = x$sample_info$sample[!x$sample_info$sample %in% x$stand_OLs$outliers]))
                obj <- lapply(obj,
                              do_stand,
                              slot = "log2")
        }
        
        # Do PCAs
        obj_pcalst <- lapply(obj,
                             function(x) prcomp(x$stand,
                                                scale. = F,
                                                center = F))
        
        # Plot PCAs
        pca_multplts_group <- plot_pca_list(obj_pcalst,
                                            lapply(obj,
                                                   function(x) x$sample_info),
                                            col = "group",
                                            nComps = 5,
                                            point_size = .5,
                                            multplot = T)
        pca_multplts_regroup <- plot_pca_list(obj_pcalst,
                                              lapply(obj,
                                                     function(x) x$sample_info),
                                              col = "clin_regrouping",
                                              nComps = 5,
                                              point_size = .5,
                                              multplot = T)
        
        pca_plts_group <- plot_pca_list(obj_pcalst,
                                        lapply(obj,
                                               function(x) x$sample_info),
                                        col = "group",
                                        point_size = .5,
                                        labs_list = lapply(obj,
                                                           function(x) x$stand_OLs$outliers),
                                        multplot = F)
        pca_plts_regroup <- plot_pca_list(obj_pcalst,
                                          lapply(obj,
                                                 function(x) x$sample_info),
                                          col = "clin_regrouping",
                                          point_size = .5,
                                          labs_list = lapply(obj,
                                                             function(x) x$stand_OLs$outliers),
                                          multplot = F)
        
        if (treat == "all"){
                pca_multplts_treat <- plot_pca_list(obj_pcalst,
                                                    lapply(obj,
                                                           function(x) x$sample_info),
                                                    col = "treatment",
                                                    nComps = 9,
                                                    point_size = .5,
                                                    multplot = T)
                pca_plts_treat <- plot_pca_list(obj_pcalst,
                                                lapply(obj,
                                                       function(x) x$sample_info),
                                                col = "treatment",
                                                point_size = .5,
                                                labs_list = lapply(obj,
                                                                   function(x) x$stand_OLs$outliers),
                                                multplot = F)
                save_plotList(pca_multplts_treat,
                              outDir = pca_dir_treat,
                              tag = "treatment_multpca",
                              height = 10,
                              width = 10)
                save_plotList(pca_plts_treat,
                              outDir = pca_dir_treat,
                              tag = "treatment_pca",
                              height = 4,
                              width = 5)
        }
        
        
        save_plotList(pca_multplts_group,
                      outDir = pca_dir_treat,
                      tag = "group_multpca",
                      height = 7,
                      width = 7)
        
        save_plotList(pca_multplts_regroup,
                      outDir = pca_dir_treat,
                      tag = "clin_regroup_multpca",
                      height = 7,
                      width = 7)
        
        save_plotList(pca_plts_group,
                      outDir = pca_dir_treat,
                      tag = "group_pca",
                      height = 4,
                      width = 5)
        
        save_plotList(pca_plts_regroup,
                      outDir = pca_dir_treat,
                      tag = "clin_regroup_pca",
                      height = 4,
                      width = 5)
}
